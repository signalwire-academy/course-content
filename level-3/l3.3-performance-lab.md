---
layout: default
title: "Lab 3.3: Performance Optimization"
parent: "Level 3: Advanced"
nav_order: 23
---
<p style="background: #dff0d8; border: 1px solid #3c763d; border-radius: 4px; padding: 15px; margin: 20px 0;">
<strong>ðŸŽ“ Ready to start this lab?</strong><br>
<a href="https://classroom.github.com/a/esS7Jp0u" target="_blank"><strong>Accept this assignment on GitHub Classroom</strong></a> to get your own repository.
</p>


**Duration:** 90 minutes
**Prerequisites:** Module 3.3 completed

## Objectives

- Profile an existing agent
- Implement caching and timeouts
- Configure optimal speech settings
- Measure improvement with benchmarks

## Scenario

You have a slow agent that needs optimization. Identify bottlenecks and fix them.

---

## Part 1: Baseline Measurement (20 min)

### The Slow Agent

Create `slow_agent.py`:

```python
#!/usr/bin/env python3
"""Intentionally slow agent for optimization lab."""

import time
import requests
from signalwire_agents import AgentBase, SwaigFunctionResult


class SlowAgent(AgentBase):
    def __init__(self):
        super().__init__(name="slow-agent")

        # Verbose prompt (anti-pattern)
        self.prompt_add_section(
            "Role",
            "You are an incredibly helpful, extremely knowledgeable, and "
            "wonderfully friendly customer service representative who works "
            "for our amazing company. Your job is to assist customers with "
            "any and all inquiries they might have about our products, "
            "services, policies, procedures, and anything else they need. "
            "You should always be polite, professional, and patient. "
            "Remember to greet customers warmly and thank them for calling. "
            "Always ask if there's anything else you can help with before "
            "ending the conversation. Be sure to speak clearly and at a "
            "moderate pace so customers can understand you easily."
        )

        self.add_language("English", "en-US", "rime.spore")
        self._setup_functions()

    def _setup_functions(self):
        @self.tool(description="Look up product information")
        def get_product(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            product_id = args.get("product_id", "")
            # Simulated slow API call (no timeout!)
            time.sleep(2)  # Artificial delay
            return SwaigFunctionResult(f"Product {product_id}: Widget Pro, $99.99")

        @self.tool(description="Check inventory")
        def check_inventory(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            sku = args.get("sku", "")
            # Multiple slow calls
            time.sleep(1)
            warehouse_a = 10
            time.sleep(1)
            warehouse_b = 5
            time.sleep(1)
            warehouse_c = 15

            return SwaigFunctionResult(
                f"Inventory for {sku}: {warehouse_a + warehouse_b + warehouse_c} total"
            )

        @self.tool(description="Calculate shipping")
        def calculate_shipping(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            zip_code = args.get("zip_code", "")
            weight = args.get("weight", 0.0)
            # Slow external call without timeout
            try:
                response = requests.get(
                    f"https://httpbin.org/delay/3",  # Intentionally slow
                    timeout=30  # Way too long
                )
                return SwaigFunctionResult(f"Shipping to {zip_code}: $12.99")
            except Exception as e:
                return SwaigFunctionResult(f"Error: {str(e)}")


if __name__ == "__main__":
    agent = SlowAgent()
    agent.run()
```

### Measure Baseline

```bash
# Time function execution
time swaig-test slow_agent.py --exec get_product --product_id "12345"

# Time inventory check
time swaig-test slow_agent.py --exec check_inventory --sku "WIDGET-001"

# Time shipping calculation
time swaig-test slow_agent.py --exec calculate_shipping \
  --zip_code "90210" --weight "2.5"
```

### Record Results

Create `performance_baseline.md`:

```markdown
# Performance Baseline

| Function | Time (seconds) | Notes |
|----------|----------------|-------|
| get_product | | |
| check_inventory | | |
| calculate_shipping | | |

## Prompt Analysis
- Word count: [count]
- Issues identified: [list]
```

---

## Part 2: Implement Optimizations (40 min)

### Task

Create `optimized_agent.py` with all performance improvements.

### Optimizations to Implement

**1. Concise Prompt**

```python
def _configure_prompts(self):
    self.prompt_add_section(
        "Role",
        "Customer service agent. Help with products, inventory, and shipping."
    )

    self.prompt_add_section(
        "Guidelines",
        bullets=[
            "Be helpful and concise",
            "Confirm before taking actions",
            "Offer alternatives when needed"
        ]
    )
```

**2. Function with Timeout and Fillers**

```python
@self.tool(
    description="Look up product information",
    fillers=["Looking that up...", "Checking our catalog..."]
)
def get_product(self, args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    product_id = args.get("product_id", "")
    try:
        # Simulated API with timeout
        result = self._fetch_product_with_timeout(product_id, timeout=2)
        return SwaigFunctionResult(f"Product {product_id}: {result}")
    except TimeoutError:
        return SwaigFunctionResult(
            "I'm having trouble loading product details. "
            "Can I help with something else?"
        )

def _fetch_product_with_timeout(self, product_id: str, timeout: int):
    import concurrent.futures

    with concurrent.futures.ThreadPoolExecutor() as executor:
        future = executor.submit(self._fetch_product, product_id)
        try:
            return future.result(timeout=timeout)
        except concurrent.futures.TimeoutError:
            raise TimeoutError("Product fetch timed out")

def _fetch_product(self, product_id: str):
    # Actual API call
    time.sleep(0.5)  # Simulated reasonable delay
    return "Widget Pro, $99.99"
```

**3. Parallel Inventory Check**

```python
import concurrent.futures

@self.tool(
    description="Check inventory",
    fillers=["Checking all warehouses..."]
)
def check_inventory(self, args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    sku = args.get("sku", "")
    # Parallel warehouse checks
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = {
            executor.submit(self._check_warehouse, "A"): "A",
            executor.submit(self._check_warehouse, "B"): "B",
            executor.submit(self._check_warehouse, "C"): "C"
        }

        total = 0
        for future in concurrent.futures.as_completed(futures, timeout=3):
            try:
                total += future.result()
            except Exception:
                pass  # Skip failed warehouse

    return SwaigFunctionResult(f"Inventory for {sku}: {total} total")

def _check_warehouse(self, warehouse: str) -> int:
    time.sleep(0.3)  # Simulated delay
    return {"A": 10, "B": 5, "C": 15}.get(warehouse, 0)
```

**4. Cached Shipping Calculation**

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def _get_shipping_rate(self, zone: str) -> float:
    """Cached shipping rate lookup."""
    # This would normally call external API
    zones = {"west": 9.99, "central": 11.99, "east": 12.99}
    return zones.get(zone, 14.99)

@self.tool(
    description="Calculate shipping",
    fillers=["Calculating shipping cost..."]
)
def calculate_shipping(self, args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    zip_code = args.get("zip_code", "")
    weight = args.get("weight", 0.0)
    # Determine zone from zip (cached logic)
    zone = self._zip_to_zone(zip_code)

    # Get cached rate
    base_rate = self._get_shipping_rate(zone)
    total = base_rate + (weight * 0.50)

    return SwaigFunctionResult(f"Shipping to {zip_code}: ${total:.2f}")

def _zip_to_zone(self, zip_code: str) -> str:
    first_digit = zip_code[0] if zip_code else "5"
    if first_digit in "012":
        return "east"
    elif first_digit in "345":
        return "central"
    else:
        return "west"
```

**5. Speech Timing Configuration**

```python
def _configure_timing(self):
    self.set_params({
        "end_of_speech_timeout": 400,  # Slightly faster
        "attention_timeout": 8000,
        "barge_min_words": 2  # Require 2 words to interrupt
    })
```

---

## Part 3: Complete Optimized Agent (10 min)

### Full Implementation

```python
#!/usr/bin/env python3
"""Optimized agent with performance improvements."""

import time
import concurrent.futures
from functools import lru_cache
from signalwire_agents import AgentBase, SwaigFunctionResult


class OptimizedAgent(AgentBase):
    def __init__(self):
        super().__init__(name="optimized-agent")

        self._configure_prompts()
        self._configure_timing()
        self.add_language("English", "en-US", "rime.spore")
        self._setup_functions()

    def _configure_prompts(self):
        self.prompt_add_section(
            "Role",
            "Customer service agent. Help with products, inventory, shipping."
        )
        self.prompt_add_section(
            "Guidelines",
            bullets=["Be helpful and concise", "Confirm before acting"]
        )

    def _configure_timing(self):
        self.set_params({
            "end_of_speech_timeout": 400,
            "attention_timeout": 8000,
            "barge_min_words": 2
        })

    @lru_cache(maxsize=100)
    def _get_shipping_rate(self, zone: str) -> float:
        return {"west": 9.99, "central": 11.99, "east": 12.99}.get(zone, 14.99)

    def _zip_to_zone(self, zip_code: str) -> str:
        first = zip_code[0] if zip_code else "5"
        return {"0": "east", "1": "east", "2": "east",
                "3": "central", "4": "central", "5": "central"}.get(first, "west")

    def _check_warehouse(self, warehouse: str) -> int:
        time.sleep(0.3)
        return {"A": 10, "B": 5, "C": 15}.get(warehouse, 0)

    def _setup_functions(self):
        @self.tool(description="Look up product", fillers=["Looking that up..."])
        def get_product(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            product_id = args.get("product_id", "")
            time.sleep(0.5)  # Fast simulated lookup
            return SwaigFunctionResult(f"Product {product_id}: Widget Pro, $99.99")

        @self.tool(description="Check inventory", fillers=["Checking warehouses..."])
        def check_inventory(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            sku = args.get("sku", "")
            with concurrent.futures.ThreadPoolExecutor(max_workers=3) as ex:
                futures = [ex.submit(self._check_warehouse, w) for w in ["A", "B", "C"]]
                total = sum(f.result(timeout=2) for f in futures)
            return SwaigFunctionResult(f"Inventory for {sku}: {total} total")

        @self.tool(description="Calculate shipping", fillers=["Calculating..."])
        def calculate_shipping(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
            zip_code = args.get("zip_code", "")
            weight = args.get("weight", 0.0)
            zone = self._zip_to_zone(zip_code)
            rate = self._get_shipping_rate(zone)
            total = rate + (weight * 0.50)
            return SwaigFunctionResult(f"Shipping to {zip_code}: ${total:.2f}")


if __name__ == "__main__":
    agent = OptimizedAgent()
    agent.run()
```

---

## Part 4: Measure Improvement (20 min)

### Benchmark Optimized Version

```bash
# Time function execution
time swaig-test optimized_agent.py --exec get_product --product_id "12345"

time swaig-test optimized_agent.py --exec check_inventory --sku "WIDGET-001"

time swaig-test optimized_agent.py --exec calculate_shipping \
  --zip_code "90210" --weight "2.5"
```

### Record Results

Update `performance_baseline.md`:

```markdown
# Performance Results

## Baseline (slow_agent.py)

| Function | Time (seconds) |
|----------|----------------|
| get_product | X.XX |
| check_inventory | X.XX |
| calculate_shipping | X.XX |

## Optimized (optimized_agent.py)

| Function | Time (seconds) | Improvement |
|----------|----------------|-------------|
| get_product | X.XX | XX% faster |
| check_inventory | X.XX | XX% faster |
| calculate_shipping | X.XX | XX% faster |

## Optimizations Applied

1. Concise prompts (reduced from ~150 words to ~30)
2. Parallel warehouse queries (3x speedup)
3. Cached shipping rates (instant after first call)
4. Timeout protection
5. Fillers for user experience
6. Optimized speech timing
```

---

## Validation Checklist

- [ ] Baseline measurements recorded
- [ ] All three functions optimized
- [ ] Caching implemented for shipping
- [ ] Parallel execution for inventory
- [ ] Timeouts added to external calls
- [ ] Fillers configured for slow operations
- [ ] Speech timing configured
- [ ] Improvement measured and documented

---

## Challenge Extension

Add request profiling decorator:

```python
import functools
import time
import logging

logger = logging.getLogger(__name__)

def profile(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        elapsed = (time.perf_counter() - start) * 1000
        logger.info(f"{func.__name__}: {elapsed:.2f}ms")
        return result
    return wrapper
```

---

## Submission

Submit:

1. `slow_agent.py` (original)
2. `optimized_agent.py` (improved)
3. `performance_baseline.md` (measurements)
