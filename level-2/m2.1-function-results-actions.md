---
layout: default
title: "Module 2.1: Function Results and Actions"
parent: "Level 2: Intermediate"
nav_order: 1
---

**Duration:** 2 hours
**Day:** 3 of 5

## Learning Objectives

By the end of this module, students will be able to:

- Use SwaigFunctionResult for complex responses
- Implement actions like transfers and SMS
- Chain multiple actions together
- Handle errors appropriately

## Topics

### 1. SwaigFunctionResult Deep Dive (25 min)

#### Beyond Simple Responses

In Level 1, we returned simple strings:

```python
return SwaigFunctionResult("Order shipped yesterday.")
```

But SwaigFunctionResult can do much more!

#### Constructor Options

```python
SwaigFunctionResult(
    response="Text for the AI to use",
    action=None,           # Single action
    post_process=False,    # Execute after call
)
```

#### Response Types

**String response:**

```python
return SwaigFunctionResult("Your balance is $150.")
```

**Structured data:**

```python
data = {"balance": 150, "due_date": "Jan 15"}
return SwaigFunctionResult(str(data))
```

**Empty response (action only):**

```python
return SwaigFunctionResult("").add_action(...)
```

---

### 2. Action Types (40 min)

#### Available Actions

| Action | Purpose |
|--------|---------|
| `transfer` | Transfer call to number/SIP |
| `send_sms` | Send SMS message |
| `hangup` | End the call |
| `play_audio` | Play audio file |
| `set_meta_data` | Store call metadata |
| `toggle_record` | Start/stop recording |
| `tap` | Start call tapping |
| `context_switch` | Change conversation context |

#### Transfer Action

```python
from signalwire_agents import SwaigFunctionResult

@agent.tool(description="Transfer to sales department")
def transfer_to_sales(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    result = SwaigFunctionResult("Transferring you to sales now.")
    result.add_action("transfer", {
        "dest": "+15551234567"
    })
    return result
```

#### SMS Action

```python
@agent.tool(description="Send order confirmation via SMS")
def send_confirmation(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    phone = args.get("phone", "")
    order_id = args.get("order_id", "")
    result = SwaigFunctionResult("I've sent a confirmation to your phone.")
    result.add_action("send_sms", {
        "to_number": phone,
        "message": f"Your order {order_id} is confirmed!"
    })
    return result
```

#### Hangup Action

```python
@agent.tool(description="End the call politely")
def end_call(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    result = SwaigFunctionResult("Thank you for calling. Goodbye!")
    result.add_action("hangup", {
        "reason": "completed"
    })
    return result
```

---

### 3. Method Chaining (20 min)

#### Fluent API

SwaigFunctionResult supports chaining:

```python
@agent.tool(description="Complete order and notify customer")
def complete_order(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    order_id = args.get("order_id", "")
    phone = args.get("phone", "")
    return (
        SwaigFunctionResult(f"Order {order_id} is complete.")
        .add_action("send_sms", {
            "to_number": phone,
            "message": f"Order {order_id} complete! Thank you."
        })
        .add_action("set_meta_data", {
            "order_id": order_id,
            "status": "completed"
        })
    )
```

#### Multiple Actions

Actions execute in order:

```python
return (
    SwaigFunctionResult("Processing your request...")
    .add_action("toggle_record", {"state": "pause"})  # First
    .add_action("send_sms", {"to_number": phone, "message": "..."})  # Second
    .add_action("toggle_record", {"state": "resume"})  # Third
)
```

---

### 4. Post-Process Actions (20 min)

#### What is Post-Process?

Post-process actions execute AFTER the AI conversation ends:

```python
@agent.tool(description="Transfer to specialist after gathering info")
def request_callback(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    result = SwaigFunctionResult(
        "I'll have a specialist call you back. "
        "Thank you for your patience."
    )
    # This transfer happens after AI says goodbye
    result.add_action("transfer", {
        "dest": "+15559876543"
    }, post_process=True)
    return result
```

#### Use Cases

| Use Case | Why Post-Process |
|----------|------------------|
| Transfer after summary | Let AI finish first |
| Send final SMS | After call completes |
| Log final data | After conversation |

---

### 5. Error Handling (15 min)

#### Graceful Failures

```python
@agent.tool(description="Process payment")
def process_payment(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    amount = args.get("amount", 0.0)
    card_last_four = args.get("card_last_four", "")
    try:
        # Attempt payment
        success = payment_api.charge(amount, card_last_four)

        if success:
            return SwaigFunctionResult(
                f"Payment of ${amount} processed successfully."
            )
        else:
            return SwaigFunctionResult(
                "I'm sorry, the payment couldn't be processed. "
                "Please check your card details."
            )
    except Exception as e:
        # Log the error
        logger.error(f"Payment failed: {e}")

        # Return user-friendly message
        return SwaigFunctionResult(
            "I'm having trouble processing the payment right now. "
            "Would you like me to transfer you to billing?"
        )
```

#### Never Expose Technical Errors

**Bad:**

```python
return SwaigFunctionResult(f"Error: {str(e)}")  # Exposes internals
```

**Good:**

```python
return SwaigFunctionResult(
    "I'm having trouble with that. Let me transfer you to someone who can help."
)
```

---

## Complete Examples

### Customer Support with Transfer

```python
DEPARTMENTS = {
    "sales": "+15551111111",
    "support": "+15552222222",
    "billing": "+15553333333",
}

@agent.tool(
    description="Transfer caller to a department",
    parameters={
        "type": "object",
        "properties": {
            "department": {
                "type": "string",
                "enum": ["sales", "support", "billing"],
                "description": "Target department"
            }
        },
        "required": ["department"]
    }
)
def transfer_to_department(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    department = args.get("department", "")
    if department not in DEPARTMENTS:
        return SwaigFunctionResult(
            "I don't recognize that department. "
            "We have sales, support, and billing."
        )

    number = DEPARTMENTS[department]
    return (
        SwaigFunctionResult(f"Transferring you to {department} now.")
        .add_action("transfer", {"dest": number})
    )
```

### Order Completion with SMS

```python
@agent.tool(
    description="Complete an order and send confirmation",
    fillers=["Processing your order...", "Almost done..."]
)
def complete_order(args: dict, raw_data: dict = None) -> SwaigFunctionResult:
    order_id = args.get("order_id", "")
    customer_phone = args.get("customer_phone", "")
    customer_email = args.get("customer_email", "")
    # Validate order exists
    order = get_order(order_id)
    if not order:
        return SwaigFunctionResult(f"Order {order_id} not found.")

    # Process the order
    order.complete()

    # Return with confirmation SMS
    return (
        SwaigFunctionResult(
            f"Order {order_id} is complete! "
            "I'm sending a confirmation to your phone now."
        )
        .add_action("send_sms", {
            "to_number": customer_phone,
            "message": f"Order {order_id} confirmed! Total: ${order.total}"
        })
        .add_action("set_meta_data", {
            "order_id": order_id,
            "completed_at": datetime.now().isoformat()
        })
    )
```

---

## Key Takeaways

1. **SwaigFunctionResult is powerful** - Not just for text
2. **Actions extend capabilities** - Transfers, SMS, recording
3. **Chaining is clean** - Fluent API for multiple actions
4. **Post-process for sequencing** - After AI conversation
5. **Handle errors gracefully** - Never expose technical details

## Preparation for Lab 2.1

- Review action types
- Think about use cases for transfers and SMS
- Have phone numbers ready for testing

## Lab Preview

In Lab 2.1, you will:

1. Build a department routing function
2. Implement SMS confirmations
3. Create a post-process transfer
4. Handle error scenarios
